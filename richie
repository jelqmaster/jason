function mainPremium()
    getgenv().Config = {}

    repeat
        task.wait()
        local vu = game:GetService("VirtualUser")
        game:GetService("Players").LocalPlayer.Idled:connect(
            function()
                vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                wait(1)
                vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
            end
        )
    until game:IsLoaded()

    local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/jelqmaster/orionmod/main/bop"))()
    local Window =
        OrionLib:MakeWindow(
        {Name = "PS99 Script [Premium] (Ver. 0.4)", HidePremium = false, SaveConfig = false, ConfigFolder = "OrionTest"}
    )

     local Info =
            Window:MakeTab(
            {
                Name = "INFO",
                Icon = "rbxassetid://4483345998",
                PremiumOnly = false
            }
        )

    local AF =
        Window:MakeTab(
        {
            Name = "Autofarm",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab =
        Window:MakeTab(
        {
            Name = "Fishing",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab2 =
        Window:MakeTab(
        {
            Name = "Digging",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab3 =
        Window:MakeTab(
        {
            Name = "Hidden Presents",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Egg =
        Window:MakeTab(
        {
            Name = "Auto Egg",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Merchant =
        Window:MakeTab(
        {
            Name = "Merchant",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Webhook =
        Window:MakeTab(
        {
            Name = "Webhook",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab4 =
        Window:MakeTab(
        {
            Name = "Mailing/Transfer",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Misc =
        Window:MakeTab(
        {
            Name = "Misc",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Craft =
        Window:MakeTab(
        {
            Name = "Auto Craft",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab5 =
        Window:MakeTab(
        {
            Name = "VIP Features 1",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Tab6 =
        Window:MakeTab(
        {
            Name = "VIP Features 2",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    local Sniper =
        Window:MakeTab(
        {
            Name = "Booth Sniper",
            Icon = "rbxassetid://4483345998",
            PremiumOnly = false
        }
    )

    Info:AddParagraph("BEWARE!","If you paid real money or more than 1m gems for this script you got scammed.")
    Info:AddLabel("https://discord.gg/HXZtG92k")
    Info:AddButton({
    	Name = "Copy Discord Link",
    	Callback = function()
          		setclipboard("https://discord.gg/HXZtG92k")
      	end    
    })

    AF:AddTextbox(
        {
            Name = "Range",
            Default = "",
            TextDisappear = false,
            Callback = function(r)
                range = tonumber(r)
            end
        }
    )

    AF:AddToggle(
        {
            Name = "Farm all nearby in range",
            Default = false,
            Callback = function(v)
                Config.farmNear = v
                spawn(farmNear)
            end
        }
    )

    local Section =
        Tab:AddSection(
        {
            Name = "Advanced Fishing"
        }
    )

    Tab:AddToggle(
        {
            Name = "Autofish",
            Default = false,
            Callback = function(v)
                Config.autoFishA = v
                spawn(autoFishA)
            end
        }
    )

    Tab:AddButton(
        {
            Name = "TP Fishing Area",
            Callback = function()
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
                    CFrame.new(-180.852783203125, 117.92350006103516, 5175.45703125)
            end
        }
    )

    local Section =
        Tab:AddSection(
        {
            Name = "Normal Fishing"
        }
    )

    Tab:AddToggle(
        {
            Name = "Autofish",
            Default = false,
            Callback = function(v)
                Config.autoFishN = v
                spawn(autoFishN)
            end
        }
    )

    Tab:AddButton(
        {
            Name = "TP Fishing Area",
            Callback = function()
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
                    CFrame.new(
                    795.875549,
                    19.4739323,
                    1136.19189,
                    -0.999999762,
                    -1.52361546e-09,
                    -0.00072622532,
                    -1.54072566e-09,
                    1,
                    2.35599042e-08,
                    0.00072622532,
                    2.3561018e-08,
                    -0.999999762
                )
            end
        }
    )

    local Section =
        Tab2:AddSection(
        {
            Name = "Normal Digging"
        }
    )

    Tab2:AddToggle(
        {
            Name = "Auto Dig",
            Default = false,
            Callback = function(v)
                Config.autoDigN = v
                spawn(autoDigN)
            end
        }
    )

    Tab2:AddToggle(
        {
            Name = "Auto Chest",
            Default = false,
            Callback = function(v)
                Config.autoChestN = v
                spawn(autoChestN)
            end
        }
    )

    Tab2:AddButton(
        {
            Name = "Chest ESP",
            Callback = function()
                chestESPN()
            end
        }
    )

    local Section =
        Tab2:AddSection(
        {
            Name = "Advanced Digging"
        }
    )

    Tab2:AddToggle(
        {
            Name = "Auto Dig",
            Default = false,
            Callback = function(v)
                Config.autoDigA = v
                spawn(autoDigA)
            end
        }
    )

    Tab2:AddToggle(
        {
            Name = "Auto Chest",
            Default = false,
            Callback = function(v)
                Config.autoChestA = v
                spawn(autoChestA)
            end
        }
    )

    Tab2:AddButton(
        {
            Name = "TP and Collect Magic Bucket",
            Callback = function()
                magicBucket()
            end
        }
    )

    Tab2:AddButton(
        {
            Name = "Chest ESP",
            Callback = function()
                chestESPA()
            end
        }
    )

    Tab3:AddToggle(
        {
            Name = "Auto Hidden Presents",
            Default = false,
            Callback = function(v)
                Config.presentHunter = v
                spawn(presentHunter)
            end
        }
    )

    eggNames = {}

    for _, v in pairs(game.ReplicatedStorage.__DIRECTORY.Eggs["Zone Eggs"]:GetDescendants()) do
        if v:IsA("ModuleScript") then
            local nameStr = v.Name:match("(%d+) | (.+)")
            if nameStr then
                local num, name = v.Name:match("(%d+) | (.+)")
                if num and name then
                    num = tonumber(num)
                    eggNames[num] = name
                    print(name)
                end
            end
        end
    end

    dropdownOptions = {}

    for num, name in pairs(eggNames) do
        table.insert(dropdownOptions, name)
    end

    Egg:AddDropdown({
        Name = "Eggs",
        Default = "None",
        Options = dropdownOptions,
        Callback = function(egg)
            selectedEgg = egg
        end    
    })

    Egg:AddTextbox({
        Name = "Egg Hatch Amount",
        Default = "",
        TextDisappear = false,
        Callback = function(eggamt)
            openAmount = tonumber(eggamt)
        end	  
    })

    Egg:AddToggle(
        {
            Name = "Auto Hatch",
            Default = false,
            Callback = function(v)
                Config.autoHatch = v
                spawn(autoHatch)
            end
        }
    )

    Egg:AddButton(
        {
            Name = "Remove Egg Animation",
            Callback = function()
                noEggAnimation()
            end
        }
    )

    Merchant:AddButton(
        {
            Name = "Auto Merchant",
            Callback = function()
                autoMerchant()
            end
        }
    )

    Webhook:AddTextbox({
        Name = "Webhook",
        Default = "",
        TextDisappear = false,
        Callback = function(wh)
            local modifiedWebhookLink = string.gsub(wh, "discord.com", "webhook.lewistehminerz.dev")
            webhooklink = tostring(modifiedWebhookLink)
        end
    })    

    Webhook:AddToggle(
        {
            Name = "NOTIFY Huges",
            Default = false,
            Callback = function(v)
                Config.hugeNotify = v
                spawn(monitorAndNotifyHugePetIncreases)
            end
        }
    )

    Webhook:AddToggle(
        {
            Name = "NOTIFY Charm Stones",
            Default = false,
            Callback = function(v)
                Config.csNotify = v
                spawn(monitorAndNotifyCSIncreases)
            end
        }
    )

    Webhook:AddToggle(
        {
            Name = "NOTIFY Magic Shards",
            Default = false,
            Callback = function(v)
                Config.msNotify = v
                spawn(monitorAndNotifyMSIncreases)
            end
        }
    )

    Tab4:AddTextbox(
        {
            Name = "Recipient",
            Default = "",
            TextDisappear = false,
            Callback = function(ign)
                usernamel = tostring(ign)
            end
        }
    )

    Tab4:AddTextbox(
        {
            Name = "Amount to Send",
            Default = "",
            TextDisappear = false,
            Callback = function(amt)
                local function converter(input)
                    local number, suffix = input:match("^(%d+)([kmb]?)$")
                    if number then
                        number = tonumber(number)
                        if suffix == "k" then
                            return number * 1000
                        elseif suffix == "m" then
                            return number * 1000000
                        elseif suffix == "b" then
                            return number * 1000000000
                        else
                            return number
                        end
                    else
                        OrionLib:MakeNotification(
                            {
                                Name = "Invalid Input!",
                                Content = "Please use valid numbers",
                                Image = "rbxassetid://4483345998",
                                Time = 5
                            }
                        )
                        return nil
                    end
                end

                gemAmount = converter(amt)
                if gemAmount then
                    print(gemAmount)
                else
                    OrionLib:MakeNotification(
                        {
                            Name = "Error!",
                            Content = "Something went wrong.",
                            Image = "rbxassetid://4483345998",
                            Time = 5
                        }
                    )
                end
            end
        }
    )

    Tab4:AddButton(
        {
            Name = "Send Gems!",
            Callback = function()
                sendGems()
            end
        }
    )

    Misc:AddButton(
        {
            Name = "AntiAFK",
            Callback = function()
                antiAFK()
            end
        }
    )

    Misc:AddButton(
        {
            Name = "Whitescreen ON",
            Callback = function()
                turnWhiteScreenOn()
            end
        }
    )

    Misc:AddButton(
        {
            Name = "Whitescreen OFF",
            Callback = function()
                turnWhiteScreenOff()
            end
        }
    )

    Craft:AddToggle(
        {
            Name = "Auto Craft Charm Stone",
            Default = false,
            Callback = function(v)
                Config.autoCharm = v
                spawn(autoCharm)
            end
        }
    )

    Craft:AddToggle(
        {
            Name = "Auto Craft Huge Potion",
            Default = false,
            Callback = function(v)
                Config.autoHuge = v
                spawn(autoHuge)
            end
        }
    )

    Tab5:AddParagraph(
        "INFO",
        "This feature automatically sends gems to your main or another account once you accumulate a set amount, like mailing 1 million gems to your main account after farming them. Fully AFK"
    )

    Tab5:AddTextbox(
        {
            Name = "Recipient",
            Default = "",
            TextDisappear = false,
            Callback = function(ignP)
                usernameP = tostring(ignP)
            end
        }
    )

    Tab5:AddTextbox(
        {
            Name = "Amount to Send",
            Default = "",
            TextDisappear = false,
            Callback = function(amtP)
                local function converter(input)
                    local number, suffix = input:match("^(%d+)([kmb]?)$")
                    if number then
                        number = tonumber(number)
                        if suffix == "k" then
                            return number * 1000
                        elseif suffix == "m" then
                            return number * 1000000
                        elseif suffix == "b" then
                            return number * 1000000000
                        else
                            return number
                        end
                    else
                        OrionLib:MakeNotification(
                            {
                                Name = "Invalid Input!",
                                Content = "Please use valid numbers",
                                Image = "rbxassetid://4483345998",
                                Time = 5
                            }
                        )
                        return nil
                    end
                end

                gemAmountP = converter(amtP)
                if gemAmountP then
                    print(gemAmountP)
                else
                    OrionLib:MakeNotification(
                        {
                            Name = "Error!",
                            Content = "Something went wrong.",
                            Image = "rbxassetid://4483345998",
                            Time = 5
                        }
                    )
                end
            end
        }
    )

    Tab5:AddToggle(
        {
            Name = "Auto Send",
            Default = false,
            Callback = function(v)
                Config.autoSend = v
                spawn(autoSend)
            end
        }
    )

    local Section =
        Tab5:AddSection(
        {
            Name = "Auto Fuse"
        }
    )

    Tab5:AddParagraph(
        "IMPORTANT READ!",
        "Make sure to toggle edit mode and equip only 1 pet, the pet you want to fuse, must have at least 16k of that one pet and 240k+ gems to get achievement hoverboard."
    )
    Tab5:AddLabel("Must be in the fusing zone (zone 28)")
    Tab5:AddToggle(
        {
            Name = "Auto Fuse",
            Default = false,
            Callback = function(v)
                Config.autoFuse = v
                spawn(autoFuse)
            end
        }
    )

    local Section =
        Tab5:AddSection(
        {
            Name = "Auto Zone"
        }
    )

    Tab5:AddParagraph(
        "IMPORTANT READ!",
        "Make sure to give your alt account good pets and a magnet book, and some gems to buy pet equip slots. Recommended for fresh accounts."
    )
    Tab5:AddLabel("Manually Complete Zone 1 First.")

    Tab5:AddToggle(
        {
            Name = "Auto Zone",
            Default = false,
            Callback = function(v)
                Config.autoZone = v
                spawn(autoZone)
            end
        }
    )

    local Section =
        Tab5:AddSection(
        {
            Name = "Auto Flag Achievement"
        }
    )
    Tab5:AddParagraph(
        "IMPORTANT READ!",
        "Auto Place 24 Flags Down in each zone, go to zone 1 and then toggle script."
    )

    Tab5:AddDropdown({
        Name = "Flags",
        Default = "None",
        Options = {"None", "Hasty Flag", "Diamonds Flag", "Coins Flag", "Magnet Flag"},
        Callback = function(option)
            selectedFlag = option
        end    
    })
    local options = {}
    for i = 1, 99 do
        table.insert(options, tostring(i))
    end
    
    Tab5:AddDropdown({
        Name = "Zone to Stop At",
        Default = "1",
        Options = options,
        Callback = function(stop)
            selectedStop = tonumber(stop)
        end    
    })    

    Tab5:AddButton(
        {
            Name = "Auto Flag!",
            Callback = function()
                autoFlag()
            end
        }
    )

    local Section =
        Tab6:AddSection(
        {
            Name = "Auto Index"
        }
    )

    Tab6:AddParagraph("IMPORTANT!","Try not to toggle it on and off too many times, also rapid toggling might break the script.")

    local optionz = {}
    for i = 1, 112 do
        table.insert(optionz, tostring(i))
    end
    
    Tab6:AddDropdown({
        Name = "Egg to start at",
        Default = "1",
        Options = optionz,
        Callback = function(eggStart)
            selectedStart = tonumber(eggStart)
        end    
    })    

    local optionx = {}
    for i = 1, 112 do
        table.insert(optionx, tostring(i))
    end
    
    Tab6:AddDropdown({
        Name = "Egg to end at",
        Default = "1",
        Options = optionx,
        Callback = function(eggStop)
            selectedMax = tonumber(eggStop)
        end    
    })  

    Tab6:AddTextbox({
        Name = "Egg buy amount",
        Default = "",
        TextDisappear = false,
        Callback = function(eggCount)
            selectedAmount = tonumber(eggCount)
        end	  
    })

    Tab6:AddTextbox({
        Name = "buy each egg x amount of times",
        Default = "",
        TextDisappear = false,
        Callback = function(eggX)
            eggTimes = tonumber(eggX)
        end	  
    })

    Tab6:AddToggle(
        {
            Name = "Auto Index",
            Default = false,
            Callback = function(v)
                Config.autoIndex = v
                spawn(autoIndex)
            end
        }
    )

    Sniper:AddParagraph("READ ME!","Will buy everything that is at the price you set, max price is 999.")

    Sniper:AddTextbox({
        Name = "Price",
        Default = "",
        TextDisappear = false,
        Callback = function(price)
            local selectedPrice = tonumber(price)
            if selectedPrice > 999 then
                OrionLib:MakeNotification({
                    Name = "Error!",
                    Content = "You cant go higher than 999.",
                    Image = "rbxassetid://4483345998",
                    Time = 5
                })
                return
            end
        end	  
    })    

    Sniper:AddToggle(
        {
            Name = "Booth Sniper",
            Default = false,
            Callback = function(v)
                Config.boothSniper = v
                spawn(boothSniper)
            end
        }
    )

    OrionLib:Init()

    function antiAFK()
        local VirtualInputManager = game:GetService("VirtualInputManager")
        while task.wait() do
            VirtualInputManager:SendKeyEvent(true, "Space", false, game)
            task.wait(.2)
            VirtualInputManager:SendKeyEvent(false, "Space", false, game)
            task.wait(300)
        end
    end

    function noEggAnimation()
        for _, v in pairs(game.Players.LocalPlayer.PlayerScripts.Scripts.Game:GetChildren()) do
            if v.Name == "Egg Opening Frontend" then
                v:Destroy()
            end
        end
    end

    function autoCharm()
        while task.wait() and Config.autoCharm do
            game:GetService("ReplicatedStorage").Network.MagicMachine_Activate:InvokeServer("Charm Stone")
        end
    end

    function autoHuge()
        while task.wait() and Config.autoHuge do
            game:GetService("ReplicatedStorage").Network.MagicMachine_Activate:InvokeServer("Huge Potion")
        end
    end

    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = playerGui
    screenGui.Enabled = false
    
    local frame = Instance.new("Frame")
    frame.BackgroundColor3 = Color3.new(1, 1, 1)
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.Parent = screenGui
    
    function turnWhiteScreenOn()
        screenGui.Enabled = true
    end
    
    function turnWhiteScreenOff()
        screenGui.Enabled = false
    end

    function farmNear()
        while true do
            task.wait()
            if not Config.farmNear then
                break
            end

            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local playerPosition = character:WaitForChild("HumanoidRootPart").Position

            for _, v in pairs(workspace.__THINGS.Breakables:GetChildren()) do
                if not Config.farmNear then
                    return
                end

                if v:IsA("Model") then
                    local distance = (v.PrimaryPart.Position - playerPosition).magnitude
                    if distance <= range then
                        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Breakables_PlayerDealDamage"):FireServer(v.Name)
                    end
                end
            end
        end
    end

    function autoHatch()
        while task.wait() and Config.autoHatch do
            local args = {
                [1] = selectedEgg,
                [2] = openAmount
            }
            
            game:GetService("ReplicatedStorage").Network.Eggs_RequestPurchase:InvokeServer(unpack(args))        
        end
    end

    function autoFishA()
        while true do
            if not Config.autoFishA then
                break
            end

            local x = math.random(10, 20)
            local z = math.random(10, 20)

            local argsCast = {
                [1] = "AdvancedFishing",
                [2] = "RequestCast",
                [3] = Vector3.new(1470.6005859375, 61.6249885559082, -4448.0107421875) + Vector3.new(x, 0, z)
            }

            game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(unpack(argsCast))
            task.wait(3.5)

            local argsReel = {
                [1] = "AdvancedFishing",
                [2] = "RequestReel"
            }

            game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(unpack(argsReel))
            repeat
                task.wait()

                local hasFishingLine = false
                for _, descendant in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                    if descendant.Name == "FishingLine" then
                        hasFishingLine = true
                        break
                    end
                end

                if not hasFishingLine then
                    break
                end

                local argsClicked = {
                    [1] = "AdvancedFishing",
                    [2] = "Clicked"
                }

                game:GetService("ReplicatedStorage").Network.Instancing_InvokeCustomFromClient:InvokeServer(
                    unpack(argsClicked)
                )
            until not hasFishingLine
            task.wait()
        end
    end

    function autoFishN()
        while true do
            if not Config.autoFishN then
                break
            end

            local x = math.random(10, 20)
            local z = math.random(10, 20)

            local args = {
                [1] = "Fishing",
                [2] = "RequestCast",
                [3] = Vector3.new(1139.5283203125, 75.91417694091797, -3440.1162109375) + Vector3.new(x, 0, z)
            }

            game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(unpack(args))
            task.wait(3.5)

            local args = {
                [1] = "Fishing",
                [2] = "RequestReel"
            }

            game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(unpack(args))
            repeat
                task.wait()

                local hasFishingLine = false
                for _, descendant in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                    if descendant.Name == "FishingLine" then
                        hasFishingLine = true
                        break
                    end
                end

                if not hasFishingLine then
                    break
                end

                local args = {
                    [1] = "Fishing",
                    [2] = "Clicked"
                }

                game:GetService("ReplicatedStorage").Network.Instancing_InvokeCustomFromClient:InvokeServer(
                    unpack(args)
                )
            until not hasFishingLine
            task.wait()
        end
    end

    function autoDigN()
        while task.wait() do
            if not Config.autoDigN then
                break
            end

            for _, v in pairs(
                workspace.__THINGS.__INSTANCE_CONTAINER.Active.Digsite.Important.ActiveBlocks:GetChildren()
            ) do
                if
                    v:IsA("Part") and v.Name == "Part" and
                        (v.Position and
                            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).magnitude < 15)
                 then
                    for i = 1, 5 do
                        local args = {
                            [1] = "Digsite",
                            [2] = "DigBlock",
                            [3] = v:GetAttribute("Coord")
                        }

                        game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(
                            unpack(args)
                        )
                    end
                    task.wait(0.1)
                    break
                end
            end
        end
    end

    function autoChestN()
        while task.wait() and Config.autoChestN do
            for _, chest in pairs(
                workspace.__THINGS.__INSTANCE_CONTAINER.Active.Digsite.Important.ActiveChests:GetDescendants()
            ) do
                if chest:IsA("MeshPart") and chest.Name == "Top" and chest.Parent and chest.Parent.Name == "Animated" then
                    if
                        chest.Position and
                            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - chest.Position).magnitude <
                                500
                     then
                        local oldCFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

                        repeat
                            task.wait()
                            if not chest or not chest.Parent then
                                break
                            end
                            game.Players.LocalPlayer.Character.HumanoidRootPart:PivotTo(
                                chest.Parent:GetPivot() + Vector3.new(0, 5, 0)
                            )

                            local coord = chest.Parent:GetAttribute("Coord")
                            if coord then
                                local chestArgs = {
                                    [1] = "Digsite",
                                    [2] = "DigChest",
                                    [3] = coord
                                }
                                game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(
                                    unpack(chestArgs)
                                )
                            end
                        until not chest or not chest.Parent

                        task.wait(3)
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldCFrame + Vector3.new(0, 5, 0)
                        task.wait(0.1)
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldCFrame + Vector3.new(0, 5, 0)
                    end
                end
            end
        end
    end

    function chestESPN()
        local ChestsToHighlight = {
            "Animated"
        }

        local function contains(table, val)
            for i = 1, #table do
                if table[i] == val then
                    return true
                end
            end
            return false
        end

        while true do
            task.wait()

            for _, chest in pairs(
                game.Workspace.__THINGS.__INSTANCE_CONTAINER.Active.Digsite.Important.ActiveChests:GetChildren()
            ) do
                if chest:FindFirstChild("ESP") then
                    chest:FindFirstChild("ESP"):Destroy()
                end

                if contains(ChestsToHighlight, chest.Name) then
                    local tcolor = Color3.fromRGB(0, 255, 0)

                    local esp = Instance.new("BillboardGui", chest)
                    esp.Name = "ESP"
                    esp.Size = UDim2.new(5, 0, 5, 0)
                    esp.AlwaysOnTop = true

                    local frame = Instance.new("Frame", esp)
                    frame.Size = UDim2.new(1, 0, 1, 0)
                    frame.BackgroundTransparency = 0.80
                    frame.BorderSizePixel = 0
                    frame.BackgroundColor3 = tcolor

                    local label = Instance.new("TextLabel", frame)
                    label.Size = UDim2.new(1, 0, 1, 1)
                    label.BorderSizePixel = 0
                    label.TextSize = 17
                    label.Text = "Chest"
                    label.BackgroundTransparency = 1
                    label.TextColor3 = tcolor
                    label.TextStrokeColor3 = Color3.fromRGB(6, 6, 6)
                    label.TextStrokeTransparency = 0.7
                end
            end
        end
    end

    function autoDigA()
        while task.wait() do
            if not Config.autoDigA then
                break
            end

            for _, v in pairs(
                workspace.__THINGS.__INSTANCE_CONTAINER.Active.AdvancedDigsite.Important.ActiveBlocks:GetChildren()
            ) do
                if
                    v:IsA("Part") and v.Name == "Part" and
                        (v.Position and
                            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).magnitude < 15)
                 then
                    for i = 1, 5 do
                        local args = {
                            [1] = "AdvancedDigsite",
                            [2] = "DigBlock",
                            [3] = v:GetAttribute("Coord")
                        }

                        game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(
                            unpack(args)
                        )
                    end
                    task.wait(0.1)
                    break
                end
            end
        end
    end

    function autoChestA()
        while task.wait() and Config.autoChestA do
            for _, chest in pairs(
                workspace.__THINGS.__INSTANCE_CONTAINER.Active.AdvancedDigsite.Important.ActiveChests:GetDescendants()
            ) do
                if chest:IsA("MeshPart") and chest.Name == "Top" and chest.Parent and chest.Parent.Name == "Animated" then
                    if
                        chest.Position and
                            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - chest.Position).magnitude <
                                500
                     then
                        local oldCFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

                        repeat
                            task.wait()
                            if not chest or not chest.Parent then
                                break
                            end
                            game.Players.LocalPlayer.Character.HumanoidRootPart:PivotTo(
                                chest.Parent:GetPivot() + Vector3.new(0, 5, 0)
                            )

                            local coord = chest.Parent:GetAttribute("Coord")
                            if coord then
                                local args = {
                                    [1] = "AdvancedDigsite",
                                    [2] = "DigChest",
                                    [3] = coord
                                }
                                game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(
                                    unpack(args)
                                )
                            end
                        until not chest or not chest.Parent

                        task.wait(3)
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldCFrame + Vector3.new(0, 5, 0)
                        task.wait(0.1)
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldCFrame + Vector3.new(0, 5, 0)
                    end
                end
            end
        end
    end

    function magicBucket()
        for _, v in pairs(
            workspace.__THINGS.__INSTANCE_CONTAINER.Active.AdvancedDigsite.Important.ActiveBlocks:GetChildren()
        ) do
            if v.BrickColor == BrickColor.new("Royal purple") then
                game.Players.LocalPlayer.Character:MoveTo(v.Position)
                repeat
                    task.wait()
                    local args = {
                        [1] = "AdvancedDigsite",
                        [2] = "DigBlock",
                        [3] = v:GetAttribute("Coord")
                    }

                    game:GetService("ReplicatedStorage").Network.Instancing_FireCustomFromClient:FireServer(
                        unpack(args)
                    )
                until not v
            end
        end
    end

    function chestESPA()
        local ChestsToHighlight = {
            "Animated"
        }

        local function contains(table, val)
            for i = 1, #table do
                if table[i] == val then
                    return true
                end
            end
            return false
        end

        while true do
            task.wait()

            for _, chest in pairs(
                workspace.__THINGS.__INSTANCE_CONTAINER.Active.AdvancedDigsite.Important.ActiveChests:GetChildren()
            ) do
                if chest:FindFirstChild("ESP") then
                    chest:FindFirstChild("ESP"):Destroy()
                end

                if contains(ChestsToHighlight, chest.Name) then
                    local tcolor = Color3.fromRGB(0, 255, 0)

                    local esp = Instance.new("BillboardGui", chest)
                    esp.Name = "ESP"
                    esp.Size = UDim2.new(5, 0, 5, 0)
                    esp.AlwaysOnTop = true

                    local frame = Instance.new("Frame", esp)
                    frame.Size = UDim2.new(1, 0, 1, 0)
                    frame.BackgroundTransparency = 0.80
                    frame.BorderSizePixel = 0
                    frame.BackgroundColor3 = tcolor

                    local label = Instance.new("TextLabel", frame)
                    label.Size = UDim2.new(1, 0, 1, 1)
                    label.BorderSizePixel = 0
                    label.TextSize = 17
                    label.Text = "Chest"
                    label.BackgroundTransparency = 1
                    label.TextColor3 = tcolor
                    label.TextStrokeColor3 = Color3.fromRGB(6, 6, 6)
                    label.TextStrokeTransparency = 0.7
                end
            end
        end
    end

    function presentHunter()
        while Config.presentHunter do
            local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
            local result = saveModule.Get()

            local hiddenPresents = result.HiddenPresents

            for _, present in pairs(hiddenPresents) do
                local id = present.ID
                if id then
                    game:GetService("ReplicatedStorage").Network:FindFirstChild("Hidden Presents: Found"):InvokeServer(
                        id
                    )
                end
                task.wait(0.5)
            end
        end
    end

    function autoMerchant()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
            CFrame.new(215.520996, 13.6210003, 168.335007) + Vector3.new(0, 5, 0)
        task.wait(0.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
            CFrame.new(427.792023, 13.6090002, 497.579987) + Vector3.new(0, 5, 0)
        task.wait(1)
        for i = 1, 6 do
            local a, b
            repeat
                task.wait(0.3)
                a, b =
                    game:GetService("ReplicatedStorage").Network.Merchant_RequestPurchase:InvokeServer(
                    "RegularMerchant",
                    i
                )
            until not a
        end
        task.wait(0.5)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
            CFrame.new(567.216003, 13.625, 1017.68402) + Vector3.new(0, 5, 0)
        task.wait(0.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
            CFrame.new(874.140991, 13.625, 1494.69495) + Vector3.new(0, 5, 0)
        task.wait(1)
        for i = 1, 6 do
            local a, b
            repeat
                task.wait(0.3)
                a, b =
                    game:GetService("ReplicatedStorage").Network.Merchant_RequestPurchase:InvokeServer(
                    "AdvancedMerchant",
                    i
                )
            until not a
        end
    end

    function sendWebhookMessage(embed)
        local syn = syn or {}
        local request = syn.request or http_request or request
        local success, response = pcall(function()
            return request({
                Url = webhooklink,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({
                    content = "@everyone",
                    embeds = {embed}
                })
            })
        end)
        if not success then
            warn("Failed to send webhook message:", response)
        end
    end    
    
    function countHugePets()
        local Library = require(game.ReplicatedStorage.Library)
        local Save = Library.Save.Get().Inventory
        local AmountOfHuges = 0
        for _, v in pairs(Save.Pet) do
            local id = v.id
            local dir = Library.Directory.Pets[id]
            if dir.huge then
                AmountOfHuges = AmountOfHuges + 1
            end
        end
        return AmountOfHuges
    end
    
    function monitorAndNotifyHugePetIncreases()
        local previousAmountOfHuges = countHugePets()
        local lp = game.Players.LocalPlayer.Name
        while true do
            if Config.hugeNotify then
                local currentAmountOfHuges = countHugePets()
                if currentAmountOfHuges > previousAmountOfHuges then
                    local embed = {
                        title = "**🌟 HUGE PET ALERT! 🌟**",
                        description = lp .. " got a huge!",
                        color = 0xEE4B2B,
                    }
                    sendWebhookMessage(embed)
                    previousAmountOfHuges = currentAmountOfHuges
                end
            end
            wait(0.5)
        end
    end

    local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
    local HttpService = game:GetService("HttpService")

    function sendWebhookMessage(embed)
        local syn = syn or {}
        local request = syn.request or http_request or request
        local success, response = pcall(function()
            return request({
                Url = webhooklink,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({
                    content = "@everyone",
                    embeds = {embed}
                })
            })
        end)
        if not success then
            warn("Failed to send webhook message:", response)
        end
    end    

    function countCharmStones()
        local result = saveModule.Get()
        local cs = result.Inventory.Misc
        local charmStoneCount = 0
        for i, v in pairs(cs) do
            if v.id == "Charm Stone" then
                charmStoneCount = charmStoneCount + (v._am or 1)
            end
        end
        return charmStoneCount
    end

    function monitorAndNotifyCSIncreases()
        local previousCharmStoneCount = countCharmStones()
        local lp = game.Players.LocalPlayer.Name
        local debounce = false
    
        while true do
            if Config.csNotify and not debounce then
                local currentCharmStoneCount = countCharmStones()
                if currentCharmStoneCount > previousCharmStoneCount then
                    debounce = true
                    local embed = {
                        title = "Charm Stone!",
                        description = lp .. " got a charm stone!",
                        color = 0x66FF00,
                    }
                    sendWebhookMessage(embed)
                    previousCharmStoneCount = currentCharmStoneCount
    
                    wait(1)
                    debounce = false
                end
            end
            wait(0.5)
        end
    end

    local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
    local HttpService = game:GetService("HttpService")

    function sendWebhookMessage(embed)
        local syn = syn or {}
        local lp = game.Players.LocalPlayer.Name
        local request = syn.request or http_request or request
        local success, response = pcall(function()
            return request({
                Url = webhooklink,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode({
                    content = "@everyone",
                    embeds = {embed}
                })
            })
        end)
        if not success then
            warn("Failed to send webhook message:", response)
        end
    end    

    function countMagicShards()
        local result = saveModule.Get()
        local ms = result.Inventory.Misc
        local magicShardCount = 0
        for i, v in pairs(ms) do
            if v.id == "Magic Shard" then
                magicShardCount = magicShardCount + (v._am or 1)
            end
        end
        return magicShardCount
    end

    function monitorAndNotifyMSIncreases()
        local previousMagicShardCount = countMagicShards()
        local lp = game.Players.LocalPlayer.Name
        local debounce = false
    
        while true do
            if Config.msNotify and not debounce then
                local currentMagicShardCount = countMagicShards()
                if currentMagicShardCount > previousMagicShardCount then
                    debounce = true
                    local embed = {
                        title = "Magic Shard!",
                        description = lp .. " got a magic shard!",
                        color = 0xA020F0,
                    }
                    sendWebhookMessage(embed)
                    previousMagicShardCount = currentMagicShardCount
    
                    wait(1)
                    debounce = false
                end
            end
            wait(0.5)
        end
    end   

    function sendGems()
        local GetSave = function()
            return require(game.ReplicatedStorage.Library.Client.Save).Get()
        end

        for i, v in pairs(GetSave().Inventory.Currency) do
            if v.id == "Diamonds" then
                local adjustedAmount = tonumber(gemAmount)

                if adjustedAmount > v._am then
                    OrionLib:MakeNotification(
                        {
                            Name = "Error!",
                            Content = "You're trying to send more gems than you have.",
                            Image = "rbxassetid://4483345998",
                            Time = 5
                        }
                    )
                else
                    if v._am - adjustedAmount < 10000 then
                        adjustedAmount = math.max(0, adjustedAmount - 10000)
                    end

                    local args = {
                        [1] = usernamel,
                        [2] = v.id,
                        [3] = "Currency",
                        [4] = i,
                        [5] = adjustedAmount
                    }

                    game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Mailbox: Send"):InvokeServer(
                        unpack(args)
                    )
                    OrionLib:MakeNotification(
                        {
                            Name = "Success!",
                            Content = "You successfully sent " .. adjustedAmount .. " to " .. username,
                            Image = "rbxassetid://4483345998",
                            Time = 5
                        }
                    )
                end
            end
        end
    end

    function autoSend()
        while Config.autoSend do
            local GetSave = function()
                return require(game.ReplicatedStorage.Library.Client.Save).Get()
            end
            user = usernameP
            for i, v in pairs(GetSave().Inventory.Currency) do
                if v.id == "Diamonds" then
                    if v._am >= gemAmountP then
                        local args = {
                            [1] = user,
                            [2] = v.id,
                            [3] = "Currency",
                            [4] = i,
                            [5] = gemAmountP - 10000
                        }
                        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Mailbox: Send"):InvokeServer(
                            unpack(args)
                        )
                    end
                end
                task.wait(1)
            end
        end
    end

    function autoFuse()
        while task.wait(0.1) and Config.autoFuse do
            local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
            local result = saveModule.Get()

            local EquippedPet = result.EquippedPets

            for _, pet in pairs(EquippedPet) do
                local uid = pet.uid
                if uid then
                    local args = {
                        [1] = {
                            [uid] = 3
                        }
                    }

                    game:GetService("ReplicatedStorage").Network.FuseMachine_Activate:InvokeServer(unpack(args))
                end
            end
        end
    end

    function autoZone()
        local mapNames = {
            "Colorful Forest",
            "Castle",
            "Green Forest",
            "Autumn",
            "Cherry Blossom",
            "Farm",
            "Backyard",
            "Misty Falls",
            "Mine",
            "Crystal Caverns",
            "Dead Forest",
            "Dark Forest",
            "Mushroom Field",
            "Enchanted Forest",
            "Crimson Forest",
            "Jungle",
            "Jungle Temple",
            "Oasis",
            "Beach",
            "Coral Reef",
            "Shipwreck",
            "Atlantis",
            "Palm Beach",
            "Tiki",
            "Pirate Cove",
            "Pirate Tavern",
            "Shanty Town",
            "Desert Village",
            "Fossil Digsite",
            "Desert Pyramids",
            "Red Desert",
            "Wild West",
            "Grand Canyons",
            "Safari",
            "Mountains",
            "Snow Village",
            "Icy Peaks",
            "Ice Rink",
            "Ski Town",
            "Hot Springs",
            "Fire and Ice",
            "Volcano",
            "Obsidian Cave",
            "Lava Forest",
            "Underworld",
            "Underworld Bridge",
            "Underworld Castle",
            "Metal Dojo",
            "Fire Dojo",
            "Samurai Village",
            "Bamboo Forest",
            "Zen Garden",
            "Flower Field",
            "Fairytale Meadows",
            "Fairytale Castle",
            "Royal Kingdom",
            "Fairy Castle",
            "Cozy Village",
            "Rainbow River",
            "Colorful Mines",
            "Colorful Mountains",
            "Frost Mountains",
            "Ice Sculptures",
            "Snowman Town",
            "Ice Castle",
            "Polar Express",
            "Firefly Cold Forest",
            "Golden Road",
            "No Path Forest",
            "Ancient Ruins",
            "Runic Altar",
            "Wizard Tower",
            "Witch Marsh",
            "Haunted Forest",
            "Haunted Graveyard",
            "Haunted Mansion",
            "Dungeon Entrance",
            "Dungeon",
            "Treasure Dungeon",
            "Empyrean Dungeon",
            "Mythic Dungeon",
            "Cotton Candy Forest",
            "Gummy Forest",
            "Chocolate Waterfall",
            "Sweets",
            "Toys and Blocks",
            "Carnival",
            "Theme Park",
            "Clouds",
            "Cloud Garden",
            "Cloud Forest"
        }

        local function generateZones()
            local zones = {}
            for i = 2, #mapNames + 1 do
                local currentZoneName = mapNames[i - 1]
                local prevZoneName = i > 2 and mapNames[i - 2] or "1 | Spawn"

                table.insert(
                    zones,
                    {
                        name = currentZoneName,
                        gate = tostring(i) .. " | " .. currentZoneName,
                        prevZone = tostring(i - 1) .. " | " .. prevZoneName
                    }
                )
            end
            return zones
        end

        local zones = generateZones()

        while Config.autoZone do
            for _, zone in ipairs(zones) do
                local gateTransparency = game.Workspace.Map[zone.gate].INTERACT.Gate.Transparency
                if gateTransparency == 0 then
                    repeat
                        task.wait()
                        gateTransparency = game.Workspace.Map[zone.gate].INTERACT.Gate.Transparency
                        local prevZoneCFrame = game.Workspace.Map[zone.prevZone].INTERACT.BREAK_ZONES.BREAK_ZONE.CFrame

                        if zone.name == "Green Forest" then
                            for i = 1, 3 do
                                game:GetService("ReplicatedStorage").Network.EquipSlotsMachine_RequestPurchase:InvokeServer(
                                    i
                                )
                            end
                        end

                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
                            prevZoneCFrame + Vector3.new(0, 5, 0)
                        game:GetService("ReplicatedStorage").Network.Zones_RequestPurchase:InvokeServer(zone.name)
                    until gateTransparency == 1 or not Config.autoZone
                end
                if not Config.autoZone then
                    break
                end
            end
            task.wait()
        end
    end
local function destroyNearbyObjects(targetCFrame, mapLocation)
    local threshold = 1

    while true do
        local success, mapLocationObject = pcall(function()
            return game.Workspace.Map[mapLocation]
        end)

        if success and mapLocationObject and mapLocationObject:FindFirstChild("INTERACT") then
            local interactObject = mapLocationObject.INTERACT
            if interactObject:FindFirstChild("BREAK_ZONES") then
                local breakZones = interactObject.BREAK_ZONES
                for _, v in pairs(breakZones:GetChildren()) do
                    if v:IsA("BasePart") then
                        local distance = (v.CFrame.Position - targetCFrame.Position).Magnitude
                        if distance <= threshold then
                            v:Destroy()
                        end
                    end
                end
            end
        end

        wait(0.1)
    end
end

spawn(function()
    destroyNearbyObjects(CFrame.new(124.629379, 13.3689919, 576.299683), "20 | Beach")
end)
spawn(function()
    destroyNearbyObjects(CFrame.new(1489.37939, 13.4520512, 1760.04968), "46 | Underworld")
end)
spawn(function()
    destroyNearbyObjects(CFrame.new(574.262878, 13.4520512, 3284.75342), "70 | No Path Forest")
end)
spawn(function()
    destroyNearbyObjects(CFrame.new(214.122131, 24.4171562, -587.119263), "1 | Spawn")
end)

function autoFlag()
    local saveModule = require(game:GetService("ReplicatedStorage").Library.Client.Save)
    local result = saveModule.Get()
    local Flags = result.Inventory.Misc
    local flaguid
    
    for i, v in pairs(Flags) do
        if v.id == selectedFlag then
            flaguid = i
            break
        end
    end
    
    local shit = {}
    
    for _, v in pairs(game.Workspace.Map:GetChildren()) do
        if v.Name ~= "SHOP" then
            table.insert(shit, v.Name)
        end
    end
    
    local function extractNumber(str)
        local num = str:match("%d+")
        return tonumber(num) or 0
    end
    
    table.sort(shit, function(a, b)
        return extractNumber(a) < extractNumber(b)
    end)
    
    for _, zoneName in ipairs(shit) do
        for _, v in pairs(game.Workspace.Map:GetDescendants()) do
            if v.Name == "BREAK_ZONE" and v.Parent.Parent.Parent.Name == zoneName then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.CFrame + Vector3.new(0, 5, 0)
                task.wait(0.1)
                for i = 1, 24 do
                game:GetService("ReplicatedStorage").Network:FindFirstChild("Flags: Consume"):InvokeServer(selectedFlag, flaguid)            
                end
            end
        end
    
        if extractNumber(zoneName) == selectedStop then
            break
        end
    end
end

function autoIndex()
    for _, v in pairs(game.Players.LocalPlayer.PlayerScripts.Scripts.Game:GetChildren()) do
        if v.Name == "Egg Opening Frontend" then
            v:Destroy()
        end
    end

    getgenv().startEggNumber = selectedStart
    getgenv().maxEggNumber = selectedMax
    local eggAmount = selectedAmount
    local openingsPerEgg = eggTimes
    
    local function getEggCentersAndNames()
        local eggCenters = {}
        local eggNames = {}
    
        for _, v in pairs(game.Workspace.__THINGS.Eggs.Main:GetDescendants()) do
            if v.Name == "Center" then
                local numStr = v.Parent.Name:match("(%d+)")
                if numStr then
                    local num = tonumber(numStr)
                    eggCenters[num] = v
                end
            end
        end
    
        for _, v in pairs(game.ReplicatedStorage.__DIRECTORY.Eggs["Zone Eggs"]:GetDescendants()) do
            if v:IsA("ModuleScript") then
                local nameStr = v.Name:match("(%d+) | (.+)")
                if nameStr then
                    local num, name = v.Name:match("(%d+) | (.+)")
                    if num and name then
                        num = tonumber(num)
                        eggNames[num] = name
                    end
                end
            end
        end
    
        return eggCenters, eggNames
    end
    
    local function handleEgg(eggNumber, openings, eggCenters, eggNames)
        local center = eggCenters[eggNumber]
        local name = eggNames[eggNumber]
    
        if center and name then
            for i = 1, openings do
                if not Config.autoIndex then return end
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = center.CFrame
                task.wait(0.5)
                local args = {
                    [1] = name,
                    [2] = eggAmount
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Eggs_RequestPurchase"):InvokeServer(unpack(args))
                wait(2)
            end
        else
            print("Error occurred.")
        end
    end
    
    while true do
        if Config.autoIndex then
            local eggCenters, eggNames = getEggCentersAndNames()
            local currentEggNumber = getgenv().startEggNumber
    
            while currentEggNumber <= getgenv().maxEggNumber and Config.autoIndex do
                handleEgg(currentEggNumber, openingsPerEgg, eggCenters, eggNames)
                currentEggNumber = currentEggNumber + 1
                wait()
            end
        else
        end
        wait(1)
    end
end

function boothSniper()
    while task.wait() and Config.boothSniper do
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local price = tostring(selectedPrice)

        if not LocalPlayer then return end

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local userId = player.UserId

                local things = game.Workspace:FindFirstChild("__THINGS")
                if not things then return end

                local booths = things:FindFirstChild("Booths")
                if not booths then return end

                for _, v in pairs(booths:GetDescendants()) do
                    if v:IsA("Frame") and v.Parent and v.Parent.Name == "PetScroll" then
                        local buy = v:FindFirstChild("Buy")
                        if buy then
                            local cost = buy:FindFirstChild("Cost")
                            if cost and cost.Text == price then
                                local args = {
                                    [1] = userId,
                                    [2] = v.Name
                                }

                                local networkService = game:GetService("ReplicatedStorage"):FindFirstChild("Network")
                                if not networkService then return end

                                local boothsRequestPurchase = networkService:FindFirstChild("Booths_RequestPurchase")
                                if not boothsRequestPurchase then return end

                                boothsRequestPurchase:InvokeServer(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
end
end

mainPremium()
